# Позвони мне, позвони (Четвертая домашка)

**Данная домашка состоит из двух частей -- одна из них
обязательна для всех, а вторая обязательна для групп
K3240-41 и опциональна для K3242-43**

Условия домашки для обеих групп одинаковые.
Сложная версия отличается только требованиями к быстродействию.
Иными словами, простая версия заключается только в том,
чтобы реализовать необходимую логику, а для сложной версии
надо уложиться еще и в ограничения по времени.

Все тесты разбиты на дву группы -- ***Easy*** и ***Hard***.

***Easy*** проверяет корректность работы вашей программы,
на небольшом кол-ве данных и вам не надо париться о 
производительности вашего кода. 

***Hard*** проверяет эффективность вашей программы
на большом количестве данных и запросов.
Если вы выберете простую версию, то ваша программа просто
не будет запускаться на тестах из секции ***Hard***.

Если вы **из группы K3242-43**, то вы можете выбрать простую
версию домашки (по-умолчанию выбрана сложная версия). Для
этого надо отредактировать файл `CMakeLists.txt`
согласно комментарию в первой его строке. **Но если выберете
и сделаете сложную версию, то вы получите 5 доп баллов**.


## Что надо делать

Вам необходимо реализовать небольшую базу данных, которая
хранит ваши контакты и простенькую историю звонков.

### Сущности
1) Телефонный номер `number` -- произвольная строка длины 
   не более 20 симоволов, при этом пустая строка 
   тоже является корректным телефонным номемером
   (Обратите внимание, что длина телефонного номера 
   маленькая это поможет вам при релизации ***Hard*** версии)
2) Имя контакта в вашей книжке `name` -- произвольная 
   строка длины до 10'000 символов, то есть имена 
   бывают ОЧЕНЬ длинными
3) Контакт в вашей книжке `user_t` -- структура контакта, 
   состоящая  из телефонного номера `number` и имени `name`
4) Запись истории звонков `call_t` -- структура, состоящая из 
   телефонного номера `number`, на который вы звонили и длительность 
   звонка в секундах `duration_s` -- число с плавающей точкой (`double`)
5) Инфо контакта `user_info_t` -- структура, состощая из 
   контакта `user` и суммарной длительности ваших звонков 
   на этот контакт `total_call_duration_s` в секундах

### Функционал
1) Пустой конструктор должен создавать вам пустую телефонную 
   книгу (без контактов и с пустой историей звонков). 
   Постарайтесь так оформить ваш класс, чтобы его 
   можно было сделать `= default;`
2) Конструктор копирования должен создавать независимую 
   копию вашей телефонной книги. Постарайтесь так оформить ваш класс, чтобы его можно было
   сделать `= default;`
3) Деструктор -- ну тут должно быть все понятно. Постарайтесь 
   так оформить ваш класс, чтобы его можно было сделать `= default;`
4) Создание контакта `create_user`. Принимает номер `number`
   и имя `name` для добавления в вашу книжку нового контакта с
   указанным номером и указанным именем. Если контакт с таким
   номером уже есть в книжке, то метод должен вернуть `false` и
   **больше ничего не делать**. В противном случае надо добавить
   новый контакт с указанными данными и вернуть `true`.
   Таким образом **телефонный номер является *уникальным* 
   идентификатором** контакта в вашей книжке, а вот **имена 
   могут *повторяться***
5) Добавления записи истории звонков `add_call`. Принимает 
   `call_t`, который надо добавить в вашу книжку. Если контакт
   с номером, указанным в переданном `call_t` не существует в
   вашей книжке, то метод должен вернуть `false` и
   **больше ничего не делать**. В противном случае надо добавить
   запись в историю и вернуть `true`
6) Запрос истории звонков `get_calls`. Все записи в истории 
   должны быть упорядочены в том порядке, в котором они были
   добавлены с помощью метода `add_call`. Данный метод принимает
   `start_pos` и `count` и должен вернуть подотрезок истории начиная с
   индекса `start_pos` и заканчивая индексом `start_pos + count - 1` 
   (в 0-индексации).
   Обратите внимание, что этот орезок может не быть 
   подотрезком истории! Иными словами, `count` может быть `0`
   или больше, чем размер истории. `start_pos` может быть 
   дальше конца истории. **Это не является ошибками!**
   Вам просто надо вернуть ту часть, которая фактически 
   присутствует в истории, поэтому ваш результат может 
   быть короче, чем `count` или вовсе пустой!
7) Запрос поиска пользователей по префиксу имени 
   `search_users_by_name`. Представьте, что вы ищете в 
   своей книжке контакт по имени и начинаете его вводить.
   Хорошее приложение начнет вам подсказывать контакты 
   еще ДО полного ввода имени. Этот метод должен вернуть
   топ `count` инфо контактов, для которых имя пользователя
   начинается на `name_prefix`, в следующем порядке сортировки:
   сначала по **лексикографическому возрастанию имени**, 
   при равенстве имен по **убыванию суммарной 
   длительности звонков на этот номер**, при равенстве и этого,
   по **лексикографическому возрастанию номера**. Иными словами, вам надо 
   отсортировать все контакты по правилам выше, выкинуть те,
   чьи имена НЕ начинаются на `name_prefix`, из оставшихся
   вернуть топ `count`, если столько есть, в противном случае
   вернуть все что есть (возможно ничего). Но такое решение,
   очевидно, не подойдет для версии ***Hard*** -- надо будет
   придумать что-то более эффективное, используя встроенные
   контейнеры.
8) Запрос поиска пользователей по префиксу номера 
   `search_users_by_number`. Этот метод очень похож на предыдущий,
   только тут надо **фильтровать по префиксу номера** и правила
   сортировки несколько другие: 
   сначала по **убыванию суммарной
   длительности звонков на этот номер**, при равенстве по
   **лексикографическому возрастанию имени**,
   при равенстве имен по **лексикографическому возрастанию номера**.
   Иными словами, вам надо
   отсортировать все контакты по правилам выше, выкинуть те,
   чьи **телефонные номера НЕ начинаются** на `number_prefix`, 
   из оставшихся вернуть топ `count`, если столько есть,
   в противном случае вернуть все что есть (возможно ничего).
   Для ***Easy*** версии этот метод ничем особо не отличается
   от предыдущего, просто немного другие правила, а вот для
   ***Hard*** версии есть качественное отличие -- в предыдущем
   методе фильтрация и первичная сортировка были по одному и тому же
   параметру -- имени, что значительно упрощает решение. В данном
   же случае -- фильтрация идет по телефонному номеру, а 
   первичный критерий сортировки -- суммарная длительность звонков.
   Совет: подумайте над идеями бора из третьей домашки, НО
   из-за того, что номера короткие, то бор реализовывать не надо --
   можно обойтись встроенными контейнерами, пусть и не так эффективно,
   но в таймауты вы уложитесь!
9) Сброс вашей книжки `clear`. Этот метод должен опустошить 
   вашу телефонную книжку -- удалить все контакты и всю
   историю звонков
10) Узнать количество контактов в вашей книжке `size`
11) Проверить что ваша книжка пуста `empty`
   
## Что можно менять
Есть два файла `phone-book.h` и `phone-book.cpp`. 

В `phone-book.h` надо дополнить декларацию класса записной 
книжки. Менять можно только **приватный** интерфес класса
`phone_book_t` и список `#include`

В `phone-book.cpp` вам надо реализовать публичный интерфейс
(и приватный, если вы добавили туда какие-то методы)

`CMakeLists.txt` чтобы выбрать версию :)

## Тестирование

Чтобы собрать и запустить тесты надо выполнить:

`python3 scripts/run-tests.py`

Для сложной версии тесты достаточно нагруженные и часть 
задания уложить каждый тест
в определенный таймаут -- три четверти секунды на тест.

Чтобы запустить тесты с проверкой скорости надо выполнить:

`python3 scripts/run-tests.py -c Release`

Если вы хотите узнать сколько работает ваша программа, но
ее рубят по таймауту, то вы можете запустить тесты с повышенным
таймаутом (при этом таймаут в тестирующей системе не изменится).
Для этого вам надо:

`python3 scripts/run-tests.py -c Release --timeout 100000`

Если у вас падает какой-то конкретный тест и вы хотите запускать только его,
то вы можете открыть файл в **CLion** `main-easy.cpp` или
`main-hard.cpp` (смотря для какой части домашки вы хотите
запустить тест). Найти этот тест в коде и нажать на зеленый треугольничек
слева от декларации теста. Единственный минус такого запуска в том, что
не будут проверены таймауты.

Чтобы запускать только один тест с проверкой таймаута вам надо:

`python3 scripts/run-tests.py -c Release --filter Hard.AddCallsToOneUser`

(тут `Hard.AddCallsToOneUser` -- имя теста, который выхотите запустить)


Также можно добавить опицию `--timeout 100000` чтобы запустить на одном тесте
с повышенным таймаутом
